import cv2, numpy as np, csv, pytesseract, math, os, json, datetime, pandas as pd

pytesseract.pytesseract.tesseract_cmd = r"C:\\Program Files\\Tesseract-OCR\\tesseract.exe"

def get_point(window, frame, prompt):
    print(prompt)
    pts = []
    def click(e,x,y,f,p):
        if e == cv2.EVENT_LBUTTONDOWN:
            pts.append((x, y))
            cv2.circle(frame,(x,y),5,(0,255,0),-1)
            cv2.imshow(window,frame)
    cv2.imshow(window,frame)
    cv2.setMouseCallback(window,click)
    while len(pts)<1: cv2.waitKey(1)
    cv2.destroyWindow(window)
    return pts[0]

def get_angle_points(frame, spacing):
    while True:
        clicked_points = []
        temp_frame = frame.copy()
        for deg in range(0, 91, spacing):
            print(f"Click the {deg}° mark.")
            pts = []
            def click(e,x,y,f,p):
                if e == cv2.EVENT_LBUTTONDOWN:
                    pts.append((x, y))
                    cv2.circle(temp_frame,(x,y),5,(0,255,0),-1)
                    cv2.putText(temp_frame, f"{deg}°", (x+5, y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,255,0),1)
                    cv2.imshow("Angle Selection", temp_frame)
            cv2.imshow("Angle Selection", temp_frame)
            cv2.setMouseCallback("Angle Selection", click)
            while len(pts) < 1: cv2.waitKey(1)
            clicked_points.append((deg, pts[0]))
        print("Press 'Y' to confirm these points or 'R' to redo.")
        key = None
        while key not in [ord('y'), ord('Y'), ord('r'), ord('R')]:
            key = cv2.waitKey(0)
        if key in [ord('y'), ord('Y')]:
            cv2.destroyWindow("Angle Selection")
            return clicked_points
        else:
            print("Redoing angle selection...")
            temp_frame = frame.copy()

def detect_pressure(frame, roi, save_path=None, crossing_label=None):
    x, y, w, h = roi
    cropped = frame[int(y):int(y+h), int(x):int(x+w)]
    if save_path and crossing_label is not None:
        debug_file = os.path.join(save_path, f"pressure_at_{crossing_label}deg.png")
        cv2.imwrite(debug_file, cropped)
    gray = cv2.cvtColor(cropped, cv2.COLOR_BGR2GRAY)
    gray = cv2.resize(gray, None, fx=2, fy=2, interpolation=cv2.INTER_LINEAR)
    thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                                   cv2.THRESH_BINARY_INV, 31, 15)
    config = '--oem 3 --psm 7 -c tessedit_char_whitelist=0123456789'
    txt = pytesseract.image_to_string(thresh, config=config)
    try:
        return int(txt.strip())
    except:
        return None

def generate_angle_positions(origin, clicked_points, spacing):
    # Interpolate between clicked points for 0–90
    angles = []
    for i in range(len(clicked_points)-1):
        a1, p1 = clicked_points[i]
        a2, p2 = clicked_points[i+1]
        for a in range(a1, a2, spacing):
            t = (a - a1) / (a2 - a1)
            x = p1[0] + t * (p2[0] - p1[0])
            y = p1[1] + t * (p2[1] - p1[1])
            angles.append((a, (int(x), int(y))))
    angles.append(clicked_points[-1])
    # Extend 100–180 by equal arc steps
    last_angle = clicked_points[-1][0]
    last_point = clicked_points[-1][1]
    dx = last_point[0] - origin[0]
    dy = last_point[1] - origin[1]
    radius = math.sqrt(dx*dx + dy*dy)
    start_angle = math.degrees(math.atan2(origin[1]-last_point[1], last_point[0]-origin[0]))
    for a in range(100, 181, spacing):
        theta = math.radians(start_angle - (a - last_angle))
        x = int(origin[0] + radius * math.cos(theta))
        y = int(origin[1] - radius * math.sin(theta))
        angles.append((a, (x, y)))
    return angles

def configure_video(video_path):
    cap=cv2.VideoCapture(video_path); ret,frame=cap.read(); cap.release()
    if not ret: raise ValueError(f"Could not read {video_path}")
    print(f"\nConfiguring: {os.path.basename(video_path)}")
    run_name = input("Enter run name for this video: ").strip()
    spacing = int(input("Enter angle spacing (e.g., 5, 10, 15): ").strip())
    origin = get_point(f"{os.path.basename(video_path)} - {run_name}", frame.copy(),"Click protractor origin/pivot.")
    clicked_angle_points = get_angle_points(frame.copy(), spacing)
    all_angle_positions = generate_angle_positions(origin, clicked_angle_points, spacing)
    print("Select a ROI around the tube tip and press SPACE or ENTER button!")
    tube_tip_box = cv2.selectROI(f"Tube Tip Tracking Box - {os.path.basename(video_path)} ({run_name})", frame, False); cv2.destroyWindow(f"Tube Tip Tracking Box - {os.path.basename(video_path)} ({run_name})")
    print("Select a ROI around the protractor and press SPACE or ENTER button!")
    protractor_roi = cv2.selectROI(f"Protractor ROI - {os.path.basename(video_path)} ({run_name})", frame, False); cv2.destroyWindow(f"Protractor ROI - {os.path.basename(video_path)} ({run_name})")
    print("Select a ROI around the pressure display and press SPACE or ENTER button!")
    pressure_roi = cv2.selectROI(f"Pressure Display - {os.path.basename(video_path)} ({run_name})", frame, False); cv2.destroyWindow(f"Pressure Display - {os.path.basename(video_path)} ({run_name})")
    return {
        "video": video_path,
        "run_name": run_name,
        "origin": origin,
        "angle_positions": all_angle_positions,
        "spacing": spacing,
        "tube_tip_box": tube_tip_box,
        "protractor_roi": protractor_roi,
        "pressure_roi": pressure_roi
    }

def process_video(config):
    VIDEO_PATH = config["video"]
    run_folder = config["run_name"]
    video_name = os.path.splitext(os.path.basename(VIDEO_PATH))[0]
    OUTPUT_DIR = os.path.join(os.getcwd(), "AnnotatedResults", f"{video_name}_{run_folder}")
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    OUTPUT_VIDEO = os.path.join(OUTPUT_DIR, f"{video_name}_annotated.mp4")
    OUTPUT_CSV = os.path.join(OUTPUT_DIR, "tube_crossings.csv")
    target_angles = [a for a,_ in config["angle_positions"]]
    tolerance = config["spacing"] / 2

    cap=cv2.VideoCapture(VIDEO_PATH)
    try: tracker = cv2.legacy.TrackerCSRT_create()
    except: tracker = cv2.TrackerCSRT_create()
    ret,frame=cap.read()
    tracker.init(frame, config["tube_tip_box"])
    fps=cap.get(cv2.CAP_PROP_FPS)
    w,h=int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)),int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    fourcc=cv2.VideoWriter_fourcc(*'mp4v'); out=cv2.VideoWriter(OUTPUT_VIDEO,fourcc,fps,(w,h))

    csv_file = open(OUTPUT_CSV,'w',newline='')
    csv_file.write(f"# Run Name: {run_folder}\n")
    csv_file.write(f"# Video: {os.path.basename(VIDEO_PATH)}\n")
    csv_file.write(f"# Exported: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
    writer = csv.writer(csv_file)
    writer.writerow(["Frame","Time(MM:SS)","CrossedAngle(deg)","Pressure(PSI)"])
    crossed=set(); last=-999; frame_idx=0; summary=[]

    while True:
        ret,frame=cap.read()
        if not ret: break
        success, bbox = tracker.update(frame)
        if not success: break
        tip_center = (int(bbox[0]+bbox[2]/2), int(bbox[1]+bbox[3]/2))

        for mark, pos in config["angle_positions"]:
            if (mark not in crossed or (mark < last - config["spacing"])) and (abs(tip_center[0]-pos[0])<10 and abs(tip_center[1]-pos[1])<10):
                crossed.add(mark); last=mark
                pressure = detect_pressure(frame, config["pressure_roi"], save_path=OUTPUT_DIR, crossing_label=mark)
                secs=int(frame_idx/fps); t=f"{secs//60:02}:{secs%60:02}"
                writer.writerow([frame_idx,t,mark,pressure if pressure is not None else ""])
                summary.append((mark,t,pressure))

        # Draw all angle dots
        for mark,pos in config["angle_positions"]:
            color = (0,255,0) if mark in crossed else (0,0,255)
            cv2.circle(frame,pos,3,color,-1)
            cv2.putText(frame,str(int(mark)),(pos[0]+5,pos[1]-5),cv2.FONT_HERSHEY_SIMPLEX,0.4,color,1)

        # Draw tracker box
        p1 = (int(bbox[0]), int(bbox[1])); p2 = (int(bbox[0]+bbox[2]), int(bbox[1]+bbox[3]))
        cv2.rectangle(frame, p1, p2, (255,0,0), 2)
        # Spacing label
        cv2.putText(frame, f"Spacing: {config['spacing']}°", (10,30), cv2.FONT_HERSHEY_SIMPLEX,0.7,(255,255,255),2)

        out.write(frame); frame_idx+=1

    cap.release(); out.release(); csv_file.close(); cv2.destroyAllWindows()
    print(f"Processed {os.path.basename(VIDEO_PATH)} ({len(summary)} crossings).")
    return len(summary)

# === MAIN ===
mode = input("Select mode: 1 - Single video, 2 - Batch folder: ").strip()
video_configs = []
if mode == "1":
    video_name = input("Enter video filename: ").strip()
    VIDEO_PATH = os.path.abspath(video_name)
    video_configs.append(configure_video(VIDEO_PATH))
else:
    folder = input("Enter folder path with videos: ").strip()
    videos = [os.path.join(folder,f) for f in os.listdir(folder) if f.lower().endswith(('.mp4','.mov','.avi'))]
    videos.sort()
    for v in videos:
        video_configs.append(configure_video(v))

total_crossings = 0
for cfg in video_configs:
    total_crossings += process_video(cfg)

print("\n=== Batch Processing Complete ===")
print(f"Total videos processed: {len(video_configs)}")
print(f"Total crossings recorded: {total_crossings}")
