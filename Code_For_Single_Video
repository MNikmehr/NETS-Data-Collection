import cv2, numpy as np, csv, pytesseract, math, os, json, datetime, pandas as pd

pytesseract.pytesseract.tesseract_cmd = r"C:\\Program Files\\Tesseract-OCR\\tesseract.exe"

# === Remember last-used folder ===
LAST_PATH_FILE = "last_path.txt"
if os.path.exists(LAST_PATH_FILE):
    with open(LAST_PATH_FILE, 'r') as f:
        last_dir = f.read().strip()
else:
    last_dir = os.getcwd()

# === Ask for video ===
video_name = input(f"Enter video filename (in {last_dir}): ").strip()
if os.path.isabs(video_name):
    VIDEO_PATH = video_name
    last_dir = os.path.dirname(video_name)
else:
    VIDEO_PATH = os.path.join(last_dir, video_name)
with open(LAST_PATH_FILE, 'w') as f:
    f.write(last_dir)

# === Ask for run folder name (check for conflicts) ===
while True:
    run_folder = input("Enter name for this analysis run (e.g., Test1): ").strip()
    OUTPUT_DIR = os.path.join(os.getcwd(), "AnnotatedResults", run_folder)
    if os.path.exists(OUTPUT_DIR):
        choice = input(f"Folder '{run_folder}' already exists. Overwrite? (y/n): ").strip().lower()
        if choice == 'y':
            break
        else:
            print("Please enter a new folder name.")
    else:
        os.makedirs(OUTPUT_DIR, exist_ok=True)
        break
os.makedirs(OUTPUT_DIR, exist_ok=True)

# === Auto-named outputs ===
OUTPUT_VIDEO = os.path.join(OUTPUT_DIR, f"{run_folder}_annotated.mp4")
OUTPUT_CSV = os.path.join(OUTPUT_DIR, "tube_crossings.csv")

SPACING = 10
RETRACE_THRESHOLD = 10.0

# === Helper functions ===
def get_point(window, frame, prompt):
    print(prompt)
    pts = []
    def click(e,x,y,f,p):
        if e == cv2.EVENT_LBUTTONDOWN:
            pts.append((x, y))
            cv2.circle(frame,(x,y),5,(0,255,0),-1)
            cv2.imshow(window,frame)
    cv2.imshow(window,frame)
    cv2.setMouseCallback(window,click)
    while len(pts)<1: cv2.waitKey(1)
    cv2.destroyWindow(window)
    return pts[0]

def get_angle(center, pt):
    dx, dy = pt[0]-center[0], center[1]-pt[1]
    return (math.degrees(math.atan2(dy, dx)) + 360) % 360

def map_to_arc(angle, a0, a90):
    if a90 < a0: a90 += 360
    if angle < a0: angle += 360
    return 90 * (angle - a0) / (a90 - a0)

def detect_pressure(frame, roi, save_path=None, crossing_label=None):
    x, y, w, h = roi
    cropped = frame[int(y):int(y+h), int(x):int(x+w)]
    
    # Save color snapshot for review
    if save_path and crossing_label is not None:
        debug_file = os.path.join(save_path, f"pressure_at_{crossing_label}deg.png")
        cv2.imwrite(debug_file, cropped)
    
    # Prepare for OCR (process internally)
    gray = cv2.cvtColor(cropped, cv2.COLOR_BGR2GRAY)
    gray = cv2.resize(gray, None, fx=2, fy=2, interpolation=cv2.INTER_LINEAR)
    thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                                   cv2.THRESH_BINARY_INV, 31, 15)
    config = '--oem 3 --psm 7 -c tessedit_char_whitelist=0123456789'
    txt = pytesseract.image_to_string(thresh, config=config)
    try:
        return int(txt.strip())
    except:
        return None

# === Selections ===
cap=cv2.VideoCapture(VIDEO_PATH); ret,frame=cap.read(); cap.release()
if not ret: raise ValueError("Could not read video.")
origin = get_point("Origin", frame.copy(),"Click protractor origin/pivot.")
tube_tip_point = get_point("Tube Tip", frame.copy(),"Click tube tip (center of tube).")
pt0 = get_point("0°", frame.copy(),"Click 0° reference.")
pt90 = get_point("90°", frame.copy(),"Click 90° reference.")
tube_tip_box = cv2.selectROI("Tube Tip Tracking Box", frame, False); cv2.destroyWindow("Tube Tip Tracking Box")
protractor_roi = cv2.selectROI("Protractor ROI", frame, False); cv2.destroyWindow("Protractor ROI")
pressure_roi = cv2.selectROI("Pressure Display", frame, False); cv2.destroyWindow("Pressure Display")

# Compute arc mapping
angle0, angle90 = get_angle(origin, pt0), get_angle(origin, pt90)
target_angles = np.arange(0,91,SPACING).tolist()
tolerance = SPACING / 2

# === Setup tracker (accurate CSRT) ===
cap=cv2.VideoCapture(VIDEO_PATH)
try:
    tracker = cv2.legacy.TrackerCSRT_create()
except:
    tracker = cv2.TrackerCSRT_create()
ret,frame=cap.read()
tracker.init(frame, tube_tip_box)

fps=cap.get(cv2.CAP_PROP_FPS)
w,h=int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)),int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
fourcc=cv2.VideoWriter_fourcc(*'mp4v'); out=cv2.VideoWriter(OUTPUT_VIDEO,fourcc,fps,(w,h))

# === CSV setup with metadata ===
csv_file = open(OUTPUT_CSV,'w',newline='')
csv_file.write(f"# Run Name: {run_folder}\n")
csv_file.write(f"# Video: {os.path.basename(VIDEO_PATH)}\n")
csv_file.write(f"# Exported: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
writer = csv.writer(csv_file)
writer.writerow(["Frame","Time(MM:SS)","CrossedAngle(deg)","Pressure(PSI)"])
crossed=set(); last=-999; frame_idx=0; summary=[]

start_angle=None; end_angle=None

while True:
    ret,frame=cap.read()
    if not ret: break
    success, bbox = tracker.update(frame)
    if not success: 
        print(f"Frame {frame_idx}: Tracking lost!")
        break
    tip_center = (int(bbox[0]+bbox[2]/2), int(bbox[1]+bbox[3]/2))

    # Compute current angle
    current = map_to_arc(get_angle(origin, tip_center), angle0, angle90)
    current = max(0,min(90,current))
    if start_angle is None: start_angle = current
    end_angle = current

    # Detect crossings
    for mark in target_angles:
        if (mark not in crossed or (mark < last - RETRACE_THRESHOLD)) and (abs(current - mark) <= tolerance):
            crossed.add(mark); last=mark
            pressure = detect_pressure(frame, pressure_roi, save_path=OUTPUT_DIR, crossing_label=mark)
            secs=int(frame_idx/fps); t=f"{secs//60:02}:{secs%60:02}"
            writer.writerow([frame_idx,t,mark,pressure if pressure is not None else ""])
            summary.append((mark,t,pressure))
            print(f"Crossed {mark}° at {t} ({'N/A' if pressure is None else str(pressure)+' PSI'})")

    # Draw markers
    x,y,rw,rh=protractor_roi
    for mark in target_angles:
        theta=(angle0+(angle90-angle0)*(mark/90))%360
        rad=math.radians(theta); radius=rw/1.5
        px=int(origin[0]+radius*math.cos(rad)); py=int(origin[1]-radius*math.sin(rad))
        color=(0,255,0) if mark in crossed else (0,0,255)
        cv2.circle(frame,(px,py),3,color,-1)
        cv2.putText(frame,str(int(mark)),(px+5,py-5),cv2.FONT_HERSHEY_SIMPLEX,0.4,color,1)

    # Draw tracker box
    p1 = (int(bbox[0]), int(bbox[1]))
    p2 = (int(bbox[0]+bbox[2]), int(bbox[1]+bbox[3]))
    cv2.rectangle(frame, p1, p2, (255,0,0), 2)

    out.write(frame); frame_idx+=1

cap.release(); out.release(); csv_file.close(); cv2.destroyAllWindows()

# === Save run report JSON ===
report_data = {
    "run_name": run_folder,
    "video": os.path.basename(VIDEO_PATH),
    "exported": datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
    "start_angle": start_angle,
    "end_angle": end_angle,
    "crossings": [{"angle": a, "time": t, "pressure": p} for a,t,p in summary]
}
report_path = os.path.join(OUTPUT_DIR, "run_report.json")
with open(report_path, 'w') as jf:
    json.dump(report_data, jf, indent=4)

# === Update master report ===
master_report_path = os.path.join(os.path.dirname(OUTPUT_DIR), "master_report.json")
all_reports = []
if os.path.exists(master_report_path):
    with open(master_report_path, 'r') as mf:
        try:
            all_reports = json.load(mf)
        except:
            all_reports = []
all_reports = [r for r in all_reports if r.get("run_name") != run_folder]
all_reports.append(report_data)
with open(master_report_path, 'w') as mf:
    json.dump(all_reports, mf, indent=4)

# === Create/Update master_report.csv ===
master_csv_path = os.path.join(os.path.dirname(OUTPUT_DIR), "master_report.csv")
flat_data = []
for r in all_reports:
    for c in r["crossings"]:
        flat_data.append({
            "Run Name": r["run_name"],
            "Video": r["video"],
            "Exported": r["exported"],
            "Time(MM:SS)": c["time"],
            "CrossedAngle(deg)": c["angle"],
            "Pressure(PSI)": c["pressure"],
            "StartAngle": r["start_angle"],
            "EndAngle": r["end_angle"]
        })
df = pd.DataFrame(flat_data)
df['Exported'] = pd.to_datetime(df['Exported'], errors='coerce')
df = df.sort_values(by=['Exported','Run Name'], ascending=[False, True])
df.to_csv(master_csv_path, index=False)

# === Create labeled montage ===
pressure_images = []
for a, _, _ in summary:
    img_path = os.path.join(OUTPUT_DIR, f"pressure_at_{a}deg.png")
    if os.path.exists(img_path):
        img = cv2.imread(img_path)
        if img is not None:
            cv2.putText(img, f"{a}°", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0,255,0), 2)
            pressure_images.append(img)

if pressure_images:
    max_h = max(img.shape[0] for img in pressure_images)
    resized = [cv2.resize(img, (int(img.shape[1] * max_h / img.shape[0]), max_h)) for img in pressure_images]
    montage = cv2.hconcat(resized)
    montage_path = os.path.join(OUTPUT_DIR, "pressure_montage.png")
    cv2.imwrite(montage_path, montage)
    print(f"Pressure montage saved at: {os.path.abspath(montage_path)}")

# === Print final paths ===
print("\n=== Processing complete! ===")
print(f"Annotated video saved at: {os.path.abspath(OUTPUT_VIDEO)}")
print(f"Crossings CSV saved at: {os.path.abspath(OUTPUT_CSV)}")
print(f"Run report saved at: {os.path.abspath(report_path)}")
print(f"Master report updated at: {os.path.abspath(master_report_path)}")
print(f"Master CSV updated at: {os.path.abspath(master_csv_path)}")
print(f"\nStart angle: {start_angle:.1f}°, End angle: {end_angle:.1f}°")
print(f"Total crossings this run: {len(summary)}")
